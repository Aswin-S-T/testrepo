angular.module('F1FeederApp.controllers').

	controller('alarmManagementController', function ($scope, $routeParams, $location, $rootScope, $localStorage, ergastAPIservice) {
		$scope.id = $routeParams.id;
		$scope.races = [];
		$scope.driver = null;
		$rootScope.loggedIn = false;
		$scope.userName = null;
		$scope.password = null;
		var allDeviceList = [];
		$scope.deviceAvilable = [];

		$scope.isEditMode = false;
		$scope.stableAddRule;

		if ($scope.stableAddRule == 1) {
			$scope.rulepopup = true;
		}


		$scope.showtimeinterval = true;
		var selectedRule = null;


		$('.collapse').on('shown.bs.collapse', function () {
			$(this).parent().find(".glyphicon-plus").removeClass("glyphicon-plus").addClass("glyphicon-minus");
		}).on('hidden.bs.collapse', function () {
			$(this).parent().find(".glyphicon-minus").removeClass("glyphicon-minus").addClass("glyphicon-plus");
		});

		$scope.removeRule = function (ruleToRemove) {

			//console.log("Inside remove----Rule ")

			// console.log("ruleToRemove:",ruleToRemove)
			// if (confirm("Are you sure to remove rule ?") == false) {
			//     return;
			// }
			// // if ($scope.isEditMode)
			// // {
			// //     $scope.cancelEdit();
			// // }
			// if ($scope.isEditMode) {
			//     $scope.editCancel();

			// }
			// ergastAPIservice.deleteAlarmRule(ruleToRemove, function (err) {
			//     if (!err) {
			//         alert("Successfully removed selected Rule.")

			//         for (var i = 0; i < $scope.alarmrules.length; i++) {
			//             if ($scope.alarmrules[i].ruleName == selectedRule.ruleName) {
			//                 $scope.alarmrules.splice(i, 1);
			//                 break;
			//             }
			//         }

			//     }

			// });
			// if($scope.alarmrules<=0)
			// {

			// 	alert("SORRY!..... no alarm are generated")
			// }
			// else{
			// 	if(selectedRule == null)
			// 	{
			// 		alert("please select an alarm rule");
			// 	}
			// 	else
			// 	{
			// 		if (confirm("Are you sure to remove Rule ? Removing rule will also delete all alarms generated by that rule") == false) {
			// 			return;
			// 		}
			// 	}
			// }


			if ($scope.isEditMode) {
				$scope.editCancel();

			}

			ergastAPIservice.deleteAlarmRule(ruleToRemove, function (err) {
				if (!err) {
					alert("Successfully removed selected Rule.")

					for (var i = 0; i < $scope.alarmrules.length; i++) {
						if ($scope.alarmrules[i].ruleName == selectedRule.ruleName) {
							$scope.alarmrules.splice(i, 1);
							break;
						}
					}

				}

			});
		}


		$scope.deleteAlarmRule = function () {

			if ($scope.alarmrules <= 0) {

				alert("SORRY!..... no alarm are generated")
			}
			else {
				if (selectedRule == null) {
					alert("please select an alarm rule");
				}
				else {
					if (confirm("Are you sure to remove Rule ? Removing rule will also delete all alarms generated by that rule") == false) {
						return;
					}
				}
			}


			if ($scope.isEditMode) {
				$scope.editCancel();

			}

			ergastAPIservice.deleteAlarmRule(selectedRule.ruleName, function (err) {
				if (!err) {
					alert("Successfully removed selected Rule.")

					for (var i = 0; i < $scope.alarmrules.length; i++) {
						if ($scope.alarmrules[i].ruleName == selectedRule.ruleName) {
							$scope.alarmrules.splice(i, 1);
							break;
						}
					}

				}

			});
		}

		$scope.updateRuleButtonClick = function () {

		}
		$scope.ruleDeviceTypeChanged = function () {
			showDevicesForType($scope.newRuleDevType);
			showRuleParams($scope.newRuleDevType, function () { });
		}
		$scope.editCancel = function () {
			

			$scope.isEditMode = false;

			$scope.newRuleName = null;
			$scope.newRuleActiveTime = null;
			$scope.newRuleMsg = null;
			$scope.clearingMode = null;
			$scope.newRuleDevType = null;



			


			

			for (var j = 0; j < $scope.deviceAvilable.length; j++) {
				$scope.deviceAvilable[j].isSelected = false;
			}

			for (var j = 0; j < $scope.seletedClassParamInfo.length; j++) {
				$scope.seletedClassParamInfo[j].minLimit = null;
				$scope.seletedClassParamInfo[j].maxLimit = null
			}


			$scope.rulepopup = false;
		}

		$scope.edit

		$scope.editRule = function (ruleName, clearingMode, timeInterval, message, combinedCondition, rule) {
			
			$scope.rulepopup = true;
			

			$scope.isEditMode = true;
			// load selected rule to UI.
			$scope.newRuleName = rule.ruleName;
			$scope.clearingMode = rule.clearingMode;
			$scope.newRuleActiveTime = rule.timeInterval;

			$scope.newRuleMsg = rule.message;
			$scope.ruleCombinedCondition = rule.combinedCondition;


			if (rule.type == "device") {
				
				$scope.newRuleDevType = rule.info.devType;
				showDevicesForType($scope.newRuleDevType);
				var devIds = rule.info.deviceIds;
				for (var j = 0; j < devIds.length; j++) {
					var res = $scope.deviceAvilable.find(function (obj) {
						return obj.deviceId == devIds[j].deviceId;
					});
					if (res != null) {
						res.isSelected = true;
					}
				}

				showRuleParams($scope.newRuleDevType, function () {




					var paramDefs = rule.info.paramDefs;
					for (paramName in paramDefs) {
						var res = $scope.seletedClassParamInfo.find(function (obj) {
							return obj.paramName == paramName;
						});
						if (res != null) {
							res.minLimit = paramDefs[paramName].minLimit;
							res.maxLimit = paramDefs[paramName].maxLimit;

						}
					}
				});
			}





		

			$scope.rulepopup = true;




		}


		$scope.editAlarmRule = function () {
		

			if ($scope.alarmrules <= 0) {
				alert("no alarms to edit");
			}
			else {
				if (selectedRule == null) {
					alert("please select an alarm rule");
				}
				else {
					
					$scope.isEditMode = true;
					// load selected rule to UI.
					$scope.newRuleName = selectedRule.ruleName;
					$scope.clearingMode = selectedRule.clearingMode;
					$scope.newRuleActiveTime = selectedRule.timeInterval;

					$scope.newRuleMsg = selectedRule.message;
					$scope.ruleCombinedCondition = selectedRule.combinedCondition;


					if (selectedRule.type == "device") {
						
						$scope.newRuleDevType = selectedRule.info.devType;
						showDevicesForType($scope.newRuleDevType);
						var devIds = selectedRule.info.deviceIds;
						for (var j = 0; j < devIds.length; j++) {
							var res = $scope.deviceAvilable.find(function (obj) {
								return obj.deviceId == devIds[j].deviceId;
							});
							if (res != null) {
								res.isSelected = true;
							}
						}

						showRuleParams($scope.newRuleDevType, function () {




							var paramDefs = selectedRule.info.paramDefs;
							for (paramName in paramDefs) {
								var res = $scope.seletedClassParamInfo.find(function (obj) {
									return obj.paramName == paramName;
								});
								if (res != null) {
									res.minLimit = paramDefs[paramName].minLimit;
									res.maxLimit = paramDefs[paramName].maxLimit;

								}
							}
						});
					}
				}

			}

		}

		$scope.selectRule = function (row, rule) {

			



			if ($scope.isEditMode) {
				if (confirm("Are you sure to edit")) {
					

					return;

				}
				else {
					

					$scope.editCancel()
					$scope.rulepopup = false;
				}

			}
			
			$scope.selectedRow = row;
			
			selectedRule = rule;
			



		}

		// $scope.selectRule = function (row, rule) {


		//     if ($scope.isEditMode) {
		//         if (confirm("Are you sure to cancel current edit ?"))
		//         {
		//             $scope.editCancel();
		//         }
		//         else
		//         {
		//             return;
		//         }

		//     }
		//     $scope.selectedRow = row;
		//     selectedRule = rule;



		// }

		var updateRuleInUI = function (rule) {

			for (var j = 0; j < $scope.alarmrules.length; j++) {

				if ($scope.alarmrules[j].ruleName == rule.ruleName) {
					$scope.alarmrules[j] = rule;
					break;
				}
			}

		}
		$scope.updateRuleButtonClick = function () {
			var info = getAlarmRuleObjectFromUI();
			if (info == null) {
				alert("Unable to add new rule. Unknown error!.")
				return;
			}
			ergastAPIservice.updateAlarmRule(info, function (err) {
				if (!err) {
					alert("Rule updated successfully")
					updateRuleInUI(info);
					$scope.rulepopup = false;
					$scope.editCancel();
				}
				else {
					alert("Unable to update rule, check your connection.");
				}
			});
		}

		var validateUIData = function () {


			var rule = getAlarmRuleObjectFromUI();
			
			if (rule.ruleName == null || rule.ruleName.trim() == "") {
				return false;
			}

			if (rule.info.deviceIds == null || rule.info.deviceIds.length <= 0)
				return false;


			if (rule.clearingMode == null)
				return false;

			if (rule.clearingMode == "Time")
			{
					if(rule.timeInterval == null)
					{
						return false;
					}
			}
			

			if (Object.keys(rule.info.paramDefs).length <= 0) {
				return false;
			}

			return true;
		}

		$scope.addRuleButtonClick = function () {
			

			if ($scope.deviceAvilable == null)
				return;


			if (!validateUIData()) {

				alert("Please fill manadatory parameters for the rule.");
				return;
			}
			
			var info = getAlarmRuleObjectFromUI();
			

			if (info == null) {
				alert("Unable to add new rule. Unknown error!.")
				return;
			}

			console.log("$$$$$$info.info.paramDefs:",info.info.paramDefs)

			for (x in info.info.paramDefs) {
				
				console.log("------->x:",x)

				

				if (info.info.paramDefs[x].minLimit > info.info.paramDefs[x].maxLimit) {
					
					alert("Unable to add new rule. minLimit is greater than maxlimit!.")
					return
				}

				if(x == "temperature")
				{
					if (info.info.paramDefs[x].maxLimit > 60 || info.info.paramDefs[x].maxLimit < -10) {
						alert("Unable to add new rule. temperature maxlimit -10 to 60.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < -10 || info.info.paramDefs[x].minLimit > 60) {
						alert("Unable to add new rule. temperature minlimit -10 to 60.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "pressure")
				{
					if (info.info.paramDefs[x].maxLimit > 1100 || info.info.paramDefs[x].maxLimit < 540) {
						alert("Unable to add new rule. pressure maxlimit 540 to 1100.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 540 || info.info.paramDefs[x].minLimit > 1100) {
						alert("Unable to add new rule. pressure minlimit 540 to 1100.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}

				}

				if(x== "humidity")
				{
					if (info.info.paramDefs[x].maxLimit > 90 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. humidity maxlimit 0 to 90.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 90) {
						alert("Unable to add new rule. humidity minlimit 0 to 90.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}

				}

				if(x== "PM10")
				{
					if (info.info.paramDefs[x].maxLimit > 450 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. PM10 maxlimit 0 to 450.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 450) {
						alert("Unable to add new rule. PM10 minlimit 0 to 450.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "PM2p5")
				{
					if (info.info.paramDefs[x].maxLimit > 230 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. PM2.5 maxlimit 0 to 230.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 230) {
						alert("Unable to add new rule. PM2.5 minlimit 0 to 230.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "PM1")
				{
					if (info.info.paramDefs[x].maxLimit > 100 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. PM1 maxlimit 0 to 100.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 100) {
						alert("Unable to add new rule. PM1 minlimit 0 to 100.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "CO")
				{
					if (info.info.paramDefs[x].maxLimit > 1145 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. CO maxlimit 0 to 1145.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 1145) {
						alert("Unable to add new rule. CO minlimit 0 to 1145.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "NO2")
				{
					if (info.info.paramDefs[x].maxLimit > 1880 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. NO2 maxlimit 0 to 1880.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 1880) {
						alert("Unable to add new rule. NO2 minlimit 0 to 1880.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "SO2")
				{
					if (info.info.paramDefs[x].maxLimit > 2620 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. SO2 maxlimit 0 to 2620.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 2620) {
						alert("Unable to add new rule. SO2 minlimit 0 to 2620.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "CO2")
				{
					if (info.info.paramDefs[x].maxLimit > 5000 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. CO2 maxlimit 0 to 5000.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 5000) {
						alert("Unable to add new rule. CO2 minlimit 0 to 5000.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "O3")
				{
					if (info.info.paramDefs[x].maxLimit > 2000 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. O3 maxlimit 0 to 2000.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 2000) {
						alert("Unable to add new rule. O3 minlimit 0 to 2000.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "NH3")
				{
					if (info.info.paramDefs[x].maxLimit > 3483 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. NH3 maxlimit 0 to 3483.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 3483) {
						alert("Unable to add new rule. NH3 minlimit 0 to 3483.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "noise")
				{
					if (info.info.paramDefs[x].maxLimit > 135 || info.info.paramDefs[x].maxLimit < 1) {
						alert("Unable to add new rule. noise maxlimit 1 to 135.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 1 || info.info.paramDefs[x].minLimit > 135) {
						alert("Unable to add new rule. noise minlimit 1 to 135.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "rain")
				{
					if (info.info.paramDefs[x].maxLimit > 999.8 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. rain maxlimit 0 to 999.8.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 999.8) {
						alert("Unable to add new rule. rain minlimit 0 to 999.8.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}

				if(x== "AQI")
				{
					if (info.info.paramDefs[x].maxLimit > 500 || info.info.paramDefs[x].maxLimit < 0) {
						alert("Unable to add new rule. AQI maxlimit 0 to 500.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit < 0 || info.info.paramDefs[x].minLimit > 500) {
						alert("Unable to add new rule. AQI minlimit 0 to 500.")
						return;
					}
	
					if (info.info.paramDefs[x].minLimit == info.info.paramDefs[x].maxLimit) {
						alert(" ERROR!!!!minlimit and maxlimit cannot be equal values.")
						return;
					}
				}


				

			}

			// 

			// if (info.info.paramDefs.temperature.maxLimit > 70 ||info.info.paramDefs.temperature.maxLimit < 0)
			// {
			//     alert("Unable to add new rule. temperature maxlimit 0 to 70.")
			//     return;
			// }

			// if (info.info.paramDefs.temperature.minLimit < 0 ||info.info.paramDefs.temperature.minLimit > 70)
			// {
			//     alert("Unable to add new rule. temperature minlimit 0 to 70.")
			//     return;
			// }



			ergastAPIservice.addAlarmRule(info, function (err) {
				if (!err) {
					addRuleToUI(info);
					alert("Rule added successfully")
				}
				else {
					alert("Unable to add rule");
				}
			});

			//$scope.editCancel();
			$scope.newRuleName = null;
			$scope.clearingMode = null;
			$scope.newRuleActiveTime = null;
			$scope.newRuleMsg = null;

			selectedDeviceIds = null;
			$scope.newRuleDevType = null;

			for (var j = 0; j < $scope.deviceAvilable.length; j++) {
				$scope.deviceAvilable[j].isSelected = false;
			}

			for (var j = 0; j < $scope.seletedClassParamInfo.length; j++) {
				$scope.seletedClassParamInfo[j].minLimit = null;
				$scope.seletedClassParamInfo[j].maxLimit = null
			}

			$scope.rulepopup = false;




		}

		var getAlarmRuleObjectFromUI = function () {

			var selectedDeviceIds = [];
			for (var j = 0; j < $scope.deviceAvilable.length; j++) {
				if ($scope.deviceAvilable[j].isSelected) {
					selectedDeviceIds.push({
						deviceId: $scope.deviceAvilable[j].deviceId,
						logicalDeviceId: $scope.deviceAvilable[j].tag.logicalDeviceId
					});
				}
			}

			var paramDefs = {};
			for (var j = 0; j < $scope.seletedClassParamInfo.length; j++) {
				if ($scope.seletedClassParamInfo[j].minLimit != null || $scope.seletedClassParamInfo[j].maxLimit != null) {

					paramDefs[$scope.seletedClassParamInfo[j].paramName] = {};
					paramDefs[$scope.seletedClassParamInfo[j].paramName].displayName = $scope.seletedClassParamInfo[j].displayName;
					paramDefs[$scope.seletedClassParamInfo[j].paramName].minLimit = $scope.seletedClassParamInfo[j].minLimit;
					paramDefs[$scope.seletedClassParamInfo[j].paramName].maxLimit = $scope.seletedClassParamInfo[j].maxLimit;
				}
			}


			var info = {};
			info.ruleName = $scope.newRuleName;
			info.clearingMode = $scope.clearingMode;
			if (info.clearingMode == "Time") {
				info.timeInterval = $scope.newRuleActiveTime;
			}
			info.message = $scope.newRuleMsg;
			info.combinedCondition = $scope.ruleCombinedCondition;
			info.type = "device";
			info.info = {};
			info.info.deviceIds = selectedDeviceIds;
			info.info.paramDefs = paramDefs;
			info.info.devType = $scope.newRuleDevType;
			//info.info.paramDefinitions

			return info;
		}

		var fetchAllDevices = function (completionCallBack) {

			ergastAPIservice.getDeviceCount("", function (count) {
				var i = 0;
				var fetchDevice = function () {

					ergastAPIservice.getDeviceAt(null, i, function (deviceInfo) {
						if (deviceInfo != null) {

							allDeviceList.push(
								{
									deviceId: deviceInfo.deviceId,
									logicalDeviceId: deviceInfo.logicalDeviceId,
									devFamily: deviceInfo.devFamily,
									subType: deviceInfo.subType,
									tag: deviceInfo,
								});
						}

						i++;
						if (i < count) {
							fetchDevice();
						}
						else {
							completionCallBack();
						}
					});

				}

				if (i < count) fetchDevice();

			});
		}

		var showDevicesForType = function (subType) {

			$scope.deviceAvilable = [];
			for (var i = 0; i < allDeviceList.length; i++) {
				var device = allDeviceList[i];
				if (device.subType == subType) {
					$scope.deviceAvilable.push({ deviceId: device.deviceId, tag: device.tag });
				}
			}
		}

		var showRuleParams = function (selectedSubType, callBackCompletion) {

			$scope.seletedClassParamInfo = [];
			ergastAPIservice.getDeviceSpec(selectedSubType, function (err, res) {
				if (!err && res.paramDefinitions != null) {
					$scope.seletedClassParamInfo = [];// res.paramDefinitions;
					
					for (var i = 0; i < res.paramDefinitions.length; i++) {
						if (res.paramDefinitions[i].paramName == "receivedTime") {
							continue;
						}
						if (res.paramDefinitions[i].isDisplayEnabled) {
							res.paramDefinitions[i].minLimit = null;
							res.paramDefinitions[i].maxLimit = null;
							$scope.seletedClassParamInfo.push(res.paramDefinitions[i]);


						}

					}
					
					callBackCompletion();
				}
			})
		}

		var addRuleToUI = function (rule) {
			rule.id = $scope.alarmrules.length + 1;
			$scope.alarmrules.push(rule);

		}
		var fetchCurrentRules = function (completionCallBack) {
			$scope.alarmrules = [];
			ergastAPIservice.getAlarmRuleCount(null, function (err, count) {

				if (!err && count > 0) {

					var i = 0;

					var fetchRule = function () {

						ergastAPIservice.getAlarmRuleAt(null, i, function (err1, ruleInfo) {
							addRuleToUI(ruleInfo);
							//$scope.alarmrules.push(ruleInfo);
							i++;
							if (i < count)
								fetchRule();
							else {
								completionCallBack();
							}
						})


					}

					fetchRule();


				}
				else
					completionCallBack();
			})
		}

		var initPage = function () {

			fetchAllDevices(function () {
				$scope.newRuleDevType = "AFMEthernet";
				showDevicesForType($scope.newRuleDevType);
				showRuleParams($scope.newRuleDevType, function () { });

			});

			fetchCurrentRules(function () { });
		}

		initPage();

	});